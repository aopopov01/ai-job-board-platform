"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/components/ui/NeuronicBackground.tsx":
/*!**************************************************!*\
  !*** ./src/components/ui/NeuronicBackground.tsx ***!
  \**************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ NeuronicBackground; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/../../node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/../../node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\nfunction NeuronicBackground(param) {\n    let { className = \"\", opacity = 0.7, nodeCount = 45, connectionDistance = 160, pulseSpeed = 0.02 // Smooth but visible animation\n     } = param;\n    _s();\n    const canvasRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const animationRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    const nodesRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)([]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n        const ctx = canvas.getContext(\"2d\");\n        if (!ctx) return;\n        // Initialize nodes\n        const initializeNodes = ()=>{\n            nodesRef.current = [];\n            for(let i = 0; i < nodeCount; i++){\n                nodesRef.current.push({\n                    x: Math.random() * canvas.width,\n                    y: Math.random() * canvas.height,\n                    vx: (Math.random() - 0.5) * 0.5,\n                    vy: (Math.random() - 0.5) * 0.5,\n                    pulse: Math.random() * Math.PI * 2,\n                    pulseDirection: Math.random() > 0.5 ? 1 : -1,\n                    connections: [],\n                    energy: Math.random(),\n                    lightningCharge: Math.random() * Math.PI * 2\n                });\n            }\n        };\n        // Resize canvas\n        const resizeCanvas = ()=>{\n            canvas.width = window.innerWidth;\n            canvas.height = window.innerHeight;\n            initializeNodes();\n        };\n        // Calculate connections\n        const calculateConnections = ()=>{\n            nodesRef.current.forEach((node, i)=>{\n                node.connections = [];\n                nodesRef.current.forEach((otherNode, j)=>{\n                    if (i !== j) {\n                        const dx = node.x - otherNode.x;\n                        const dy = node.y - otherNode.y;\n                        const distance = Math.sqrt(dx * dx + dy * dy);\n                        if (distance < connectionDistance) {\n                            node.connections.push(j);\n                        }\n                    }\n                });\n            });\n        };\n        // Animation loop\n        const animate = ()=>{\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            // Update nodes\n            nodesRef.current.forEach((node)=>{\n                // Update position\n                node.x += node.vx;\n                node.y += node.vy;\n                // Bounce off edges\n                if (node.x <= 0 || node.x >= canvas.width) node.vx *= -1;\n                if (node.y <= 0 || node.y >= canvas.height) node.vy *= -1;\n                // Keep nodes in bounds\n                node.x = Math.max(0, Math.min(canvas.width, node.x));\n                node.y = Math.max(0, Math.min(canvas.height, node.y));\n                // Update pulse and lightning energy\n                node.pulse += pulseSpeed * node.pulseDirection;\n                if (node.pulse > Math.PI * 2) node.pulse = 0;\n                if (node.pulse < 0) node.pulse = Math.PI * 2;\n                // Gentle energy waves for comfort\n                node.lightningCharge += pulseSpeed * 0.8;\n                node.energy = Math.sin(node.lightningCharge) * 0.2 + 0.3;\n            });\n            // Recalculate connections\n            calculateConnections();\n            // Draw connections\n            nodesRef.current.forEach((node, i)=>{\n                node.connections.forEach((connectionIndex)=>{\n                    const otherNode = nodesRef.current[connectionIndex];\n                    if (otherNode) {\n                        const dx = node.x - otherNode.x;\n                        const dy = node.y - otherNode.y;\n                        const distance = Math.sqrt(dx * dx + dy * dy);\n                        const alpha = (1 - distance / connectionDistance) * opacity * 0.8;\n                        // Visible neural connections\n                        const pulseIntensity = (Math.sin(node.pulse) + Math.sin(otherNode.pulse)) / 2;\n                        const neuralEnergy = (node.energy + otherNode.energy) / 2;\n                        const flowIntensity = Math.sin(Date.now() * 0.005 + distance * 0.03) * 0.3 + 0.7;\n                        const connectionAlpha = alpha * (0.6 + pulseIntensity * 0.3 + neuralEnergy * 0.2);\n                        // Warm, visible neural colors\n                        const neuralColor = neuralEnergy > 0.5 ? \"rgba(100, 180, 255, \".concat(connectionAlpha * flowIntensity, \")\") // Bright blue\n                         : \"rgba(80, 150, 220, \".concat(connectionAlpha, \")\") // Medium blue\n                        ;\n                        ctx.strokeStyle = neuralColor;\n                        ctx.lineWidth = 1.2 + neuralEnergy * 1.8 // Visible lines\n                        ;\n                        // Clear glow for visibility\n                        ctx.shadowColor = neuralColor;\n                        ctx.shadowBlur = 3 + neuralEnergy * 6;\n                        ctx.beginPath();\n                        ctx.moveTo(node.x, node.y);\n                        // Smooth, organic connections\n                        ctx.lineTo(otherNode.x, otherNode.y);\n                        ctx.stroke();\n                        ctx.shadowBlur = 0;\n                    }\n                });\n            });\n            // Draw gentle, comfortable nodes\n            nodesRef.current.forEach((node)=>{\n                const pulseIntensity = Math.sin(node.pulse) * 0.3 + 0.4;\n                const gentleEnergy = node.energy;\n                const nodeOpacity = opacity * (0.5 + pulseIntensity * 0.2 + gentleEnergy * 0.15);\n                const nodeSize = 2 + pulseIntensity * 2 + gentleEnergy * 1.5 // Smaller, elegant nodes\n                ;\n                const isActive = gentleEnergy > 0.5;\n                // Soft, twilight-inspired node colors\n                const nodeColor = isActive ? \"rgba(140, 165, 210, \".concat(nodeOpacity, \")\") // Soft lavender-blue\n                 : \"rgba(115, 140, 185, \".concat(nodeOpacity, \")\") // Muted slate-blue\n                ;\n                // Gentle glow for active nodes\n                if (isActive) {\n                    ctx.shadowColor = \"rgba(140, 165, 210, 0.4)\";\n                    ctx.shadowBlur = 6 + gentleEnergy * 4;\n                }\n                ctx.fillStyle = nodeColor;\n                ctx.beginPath();\n                ctx.arc(node.x, node.y, nodeSize, 0, Math.PI * 2);\n                ctx.fill();\n                // Soft inner core for depth\n                const coreColor = isActive ? \"rgba(165, 185, 220, \".concat(nodeOpacity * 0.8, \")\") : \"rgba(135, 155, 195, \".concat(nodeOpacity * 0.7, \")\");\n                ctx.fillStyle = coreColor;\n                ctx.beginPath();\n                ctx.arc(node.x, node.y, nodeSize * 0.4, 0, Math.PI * 2);\n                ctx.fill();\n                ctx.shadowBlur = 0;\n                // Gentle ambient glow\n                const glowRadius = nodeSize + pulseIntensity * 8 + gentleEnergy * 6;\n                const gradient = ctx.createRadialGradient(node.x, node.y, 0, node.x, node.y, glowRadius);\n                if (isActive) {\n                    // Soft twilight glow for active nodes\n                    gradient.addColorStop(0, \"rgba(160, 180, 215, \".concat(nodeOpacity * 0.6, \")\"));\n                    gradient.addColorStop(0.2, \"rgba(140, 165, 200, \".concat(nodeOpacity * 0.4, \")\"));\n                    gradient.addColorStop(0.5, \"rgba(120, 145, 185, \".concat(nodeOpacity * 0.25, \")\"));\n                    gradient.addColorStop(0.8, \"rgba(100, 125, 170, \".concat(nodeOpacity * 0.1, \")\"));\n                    gradient.addColorStop(1, \"rgba(80, 105, 155, 0)\");\n                } else {\n                    // Subtle glow for regular nodes\n                    gradient.addColorStop(0, \"rgba(130, 150, 185, \".concat(nodeOpacity * 0.5, \")\"));\n                    gradient.addColorStop(0.3, \"rgba(115, 135, 170, \".concat(nodeOpacity * 0.3, \")\"));\n                    gradient.addColorStop(0.6, \"rgba(100, 120, 155, \".concat(nodeOpacity * 0.15, \")\"));\n                    gradient.addColorStop(1, \"rgba(85, 105, 140, 0)\");\n                }\n                ctx.fillStyle = gradient;\n                ctx.beginPath();\n                ctx.arc(node.x, node.y, glowRadius, 0, Math.PI * 2);\n                ctx.fill();\n            });\n            animationRef.current = requestAnimationFrame(animate);\n        };\n        // Initialize\n        resizeCanvas();\n        window.addEventListener(\"resize\", resizeCanvas);\n        animate();\n        return ()=>{\n            window.removeEventListener(\"resize\", resizeCanvas);\n            if (animationRef.current) {\n                cancelAnimationFrame(animationRef.current);\n            }\n        };\n    }, [\n        opacity,\n        nodeCount,\n        connectionDistance,\n        pulseSpeed\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"canvas\", {\n        ref: canvasRef,\n        className: \"fixed inset-0 pointer-events-none z-0 \".concat(className),\n        style: {\n            opacity\n        }\n    }, void 0, false, {\n        fileName: \"/app/apps/web/src/components/ui/NeuronicBackground.tsx\",\n        lineNumber: 237,\n        columnNumber: 5\n    }, this);\n}\n_s(NeuronicBackground, \"eE7rkxSEFP3rCBRXkDJ01N1IvKk=\");\n_c = NeuronicBackground;\nvar _c;\n$RefreshReg$(_c, \"NeuronicBackground\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL3VpL05ldXJvbmljQmFja2dyb3VuZC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBRXlDO0FBc0IxQixTQUFTRSxtQkFBbUIsS0FNakI7UUFOaUIsRUFDekNDLFlBQVksRUFBRSxFQUNkQyxVQUFVLEdBQUcsRUFDYkMsWUFBWSxFQUFFLEVBQ2RDLHFCQUFxQixHQUFHLEVBQ3hCQyxhQUFhLEtBQU0sK0JBQStCO0lBQWpDLEVBQ08sR0FOaUI7O0lBT3pDLE1BQU1DLFlBQVlQLDZDQUFNQSxDQUFvQjtJQUM1QyxNQUFNUSxlQUFlUiw2Q0FBTUE7SUFDM0IsTUFBTVMsV0FBV1QsNkNBQU1BLENBQVMsRUFBRTtJQUVsQ0QsZ0RBQVNBLENBQUM7UUFDUixNQUFNVyxTQUFTSCxVQUFVSSxPQUFPO1FBQ2hDLElBQUksQ0FBQ0QsUUFBUTtRQUViLE1BQU1FLE1BQU1GLE9BQU9HLFVBQVUsQ0FBQztRQUM5QixJQUFJLENBQUNELEtBQUs7UUFFVixtQkFBbUI7UUFDbkIsTUFBTUUsa0JBQWtCO1lBQ3RCTCxTQUFTRSxPQUFPLEdBQUcsRUFBRTtZQUNyQixJQUFLLElBQUlJLElBQUksR0FBR0EsSUFBSVgsV0FBV1csSUFBSztnQkFDbENOLFNBQVNFLE9BQU8sQ0FBQ0ssSUFBSSxDQUFDO29CQUNwQkMsR0FBR0MsS0FBS0MsTUFBTSxLQUFLVCxPQUFPVSxLQUFLO29CQUMvQkMsR0FBR0gsS0FBS0MsTUFBTSxLQUFLVCxPQUFPWSxNQUFNO29CQUNoQ0MsSUFBSSxDQUFDTCxLQUFLQyxNQUFNLEtBQUssR0FBRSxJQUFLO29CQUM1QkssSUFBSSxDQUFDTixLQUFLQyxNQUFNLEtBQUssR0FBRSxJQUFLO29CQUM1Qk0sT0FBT1AsS0FBS0MsTUFBTSxLQUFLRCxLQUFLUSxFQUFFLEdBQUc7b0JBQ2pDQyxnQkFBZ0JULEtBQUtDLE1BQU0sS0FBSyxNQUFNLElBQUksQ0FBQztvQkFDM0NTLGFBQWEsRUFBRTtvQkFDZkMs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LFlBQVksR0FBR3pELEtBQUtRLEVBQUUsR0FBRztnQkFDakRkLElBQUk2RCxJQUFJO1lBQ1Y7WUFFQWpFLGFBQWFHLE9BQU8sR0FBR29FLHNCQUFzQm5DO1FBQy9DO1FBRUEsYUFBYTtRQUNiYjtRQUNBQyxPQUFPZ0QsZ0JBQWdCLENBQUMsVUFBVWpEO1FBQ2xDYTtRQUVBLE9BQU87WUFDTFosT0FBT2lELG1CQUFtQixDQUFDLFVBQVVsRDtZQUNyQyxJQUFJdkIsYUFBYUcsT0FBTyxFQUFFO2dCQUN4QnVFLHFCQUFxQjFFLGFBQWFHLE9BQU87WUFDM0M7UUFDRjtJQUNGLEdBQUc7UUFBQ1I7UUFBU0M7UUFBV0M7UUFBb0JDO0tBQVc7SUFFdkQscUJBQ0UsOERBQUNJO1FBQ0N5RSxLQUFLNUU7UUFDTEwsV0FBVyx5Q0FBbUQsT0FBVkE7UUFDcERrRixPQUFPO1lBQUVqRjtRQUFROzs7Ozs7QUFHdkI7R0ExTndCRjtLQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy91aS9OZXVyb25pY0JhY2tncm91bmQudHN4P2U1ODQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXG5cbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSAncmVhY3QnXG5cbmludGVyZmFjZSBOb2RlIHtcbiAgeDogbnVtYmVyXG4gIHk6IG51bWJlclxuICB2eDogbnVtYmVyXG4gIHZ5OiBudW1iZXJcbiAgcHVsc2U6IG51bWJlclxuICBwdWxzZURpcmVjdGlvbjogbnVtYmVyXG4gIGNvbm5lY3Rpb25zOiBudW1iZXJbXVxuICBlbmVyZ3k6IG51bWJlclxuICBsaWdodG5pbmdDaGFyZ2U6IG51bWJlclxufVxuXG5pbnRlcmZhY2UgTmV1cm9uaWNCYWNrZ3JvdW5kUHJvcHMge1xuICBjbGFzc05hbWU/OiBzdHJpbmdcbiAgb3BhY2l0eT86IG51bWJlclxuICBub2RlQ291bnQ/OiBudW1iZXJcbiAgY29ubmVjdGlvbkRpc3RhbmNlPzogbnVtYmVyXG4gIHB1bHNlU3BlZWQ/OiBudW1iZXJcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gTmV1cm9uaWNCYWNrZ3JvdW5kKHtcbiAgY2xhc3NOYW1lID0gJycsXG4gIG9wYWNpdHkgPSAwLjcsICAgLy8gTW9yZSB2aXNpYmxlXG4gIG5vZGVDb3VudCA9IDQ1LCAgLy8gTW9yZSBub2RlcyBmb3IgYmV0dGVyIHZpc2liaWxpdHlcbiAgY29ubmVjdGlvbkRpc3RhbmNlID0gMTYwLCAvLyBHb29kIGNvbm5lY3Rpb24gZGVuc2l0eVxuICBwdWxzZVNwZWVkID0gMC4wMiAgLy8gU21vb3RoIGJ1dCB2aXNpYmxlIGFuaW1hdGlvblxufTogTmV1cm9uaWNCYWNrZ3JvdW5kUHJvcHMpIHtcbiAgY29uc3QgY2FudmFzUmVmID0gdXNlUmVmPEhUTUxDYW52YXNFbGVtZW50PihudWxsKVxuICBjb25zdCBhbmltYXRpb25SZWYgPSB1c2VSZWY8bnVtYmVyPigpXG4gIGNvbnN0IG5vZGVzUmVmID0gdXNlUmVmPE5vZGVbXT4oW10pXG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBjYW52YXMgPSBjYW52YXNSZWYuY3VycmVudFxuICAgIGlmICghY2FudmFzKSByZXR1cm5cblxuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpXG4gICAgaWYgKCFjdHgpIHJldHVyblxuXG4gICAgLy8gSW5pdGlhbGl6ZSBub2Rlc1xuICAgIGNvbnN0IGluaXRpYWxpemVOb2RlcyA9ICgpID0+IHtcbiAgICAgIG5vZGVzUmVmLmN1cnJlbnQgPSBbXVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlQ291bnQ7IGkrKykge1xuICAgICAgICBub2Rlc1JlZi5jdXJyZW50LnB1c2goe1xuICAgICAgICAgIHg6IE1hdGgucmFuZG9tKCkgKiBjYW52YXMud2lkdGgsXG4gICAgICAgICAgeTogTWF0aC5yYW5kb20oKSAqIGNhbnZhcy5oZWlnaHQsXG4gICAgICAgICAgdng6IChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIDAuNSxcbiAgICAgICAgICB2eTogKE1hdGgucmFuZG9tKCkgLSAwLjUpICogMC41LFxuICAgICAgICAgIHB1bHNlOiBNYXRoLnJhbmRvbSgpICogTWF0aC5QSSAqIDIsXG4gICAgICAgICAgcHVsc2VEaXJlY3Rpb246IE1hdGgucmFuZG9tKCkgPiAwLjUgPyAxIDogLTEsXG4gICAgICAgICAgY29ubmVjdGlvbnM6IFtdLFxuICAgICAgICAgIGVuZXJneTogTWF0aC5yYW5kb20oKSxcbiAgICAgICAgICBsaWdodG5pbmdDaGFyZ2U6IE1hdGgucmFuZG9tKCkgKiBNYXRoLlBJICogMlxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJlc2l6ZSBjYW52YXNcbiAgICBjb25zdCByZXNpemVDYW52YXMgPSAoKSA9PiB7XG4gICAgICBjYW52YXMud2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aFxuICAgICAgY2FudmFzLmhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodFxuICAgICAgaW5pdGlhbGl6ZU5vZGVzKClcbiAgICB9XG5cbiAgICAvLyBDYWxjdWxhdGUgY29ubmVjdGlvbnNcbiAgICBjb25zdCBjYWxjdWxhdGVDb25uZWN0aW9ucyA9ICgpID0+IHtcbiAgICAgIG5vZGVzUmVmLmN1cnJlbnQuZm9yRWFjaCgobm9kZSwgaSkgPT4ge1xuICAgICAgICBub2RlLmNvbm5lY3Rpb25zID0gW11cbiAgICAgICAgbm9kZXNSZWYuY3VycmVudC5mb3JFYWNoKChvdGhlck5vZGUsIGopID0+IHtcbiAgICAgICAgICBpZiAoaSAhPT0gaikge1xuICAgICAgICAgICAgY29uc3QgZHggPSBub2RlLnggLSBvdGhlck5vZGUueFxuICAgICAgICAgICAgY29uc3QgZHkgPSBub2RlLnkgLSBvdGhlck5vZGUueVxuICAgICAgICAgICAgY29uc3QgZGlzdGFuY2UgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpXG4gICAgICAgICAgICBpZiAoZGlzdGFuY2UgPCBjb25uZWN0aW9uRGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgbm9kZS5jb25uZWN0aW9ucy5wdXNoKGopXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyBBbmltYXRpb24gbG9vcFxuICAgIGNvbnN0IGFuaW1hdGUgPSAoKSA9PiB7XG4gICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodClcbiAgICAgIFxuICAgICAgLy8gVXBkYXRlIG5vZGVzXG4gICAgICBub2Rlc1JlZi5jdXJyZW50LmZvckVhY2gobm9kZSA9PiB7XG4gICAgICAgIC8vIFVwZGF0ZSBwb3NpdGlvblxuICAgICAgICBub2RlLnggKz0gbm9kZS52eFxuICAgICAgICBub2RlLnkgKz0gbm9kZS52eVxuXG4gICAgICAgIC8vIEJvdW5jZSBvZmYgZWRnZXNcbiAgICAgICAgaWYgKG5vZGUueCA8PSAwIHx8IG5vZGUueCA+PSBjYW52YXMud2lkdGgpIG5vZGUudnggKj0gLTFcbiAgICAgICAgaWYgKG5vZGUueSA8PSAwIHx8IG5vZGUueSA+PSBjYW52YXMuaGVpZ2h0KSBub2RlLnZ5ICo9IC0xXG5cbiAgICAgICAgLy8gS2VlcCBub2RlcyBpbiBib3VuZHNcbiAgICAgICAgbm9kZS54ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oY2FudmFzLndpZHRoLCBub2RlLngpKVxuICAgICAgICBub2RlLnkgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihjYW52YXMuaGVpZ2h0LCBub2RlLnkpKVxuXG4gICAgICAgIC8vIFVwZGF0ZSBwdWxzZSBhbmQgbGlnaHRuaW5nIGVuZXJneVxuICAgICAgICBub2RlLnB1bHNlICs9IHB1bHNlU3BlZWQgKiBub2RlLnB1bHNlRGlyZWN0aW9uXG4gICAgICAgIGlmIChub2RlLnB1bHNlID4gTWF0aC5QSSAqIDIpIG5vZGUucHVsc2UgPSAwXG4gICAgICAgIGlmIChub2RlLnB1bHNlIDwgMCkgbm9kZS5wdWxzZSA9IE1hdGguUEkgKiAyXG4gICAgICAgIFxuICAgICAgICAvLyBHZW50bGUgZW5lcmd5IHdhdmVzIGZvciBjb21mb3J0XG4gICAgICAgIG5vZGUubGlnaHRuaW5nQ2hhcmdlICs9IHB1bHNlU3BlZWQgKiAwLjhcbiAgICAgICAgbm9kZS5lbmVyZ3kgPSBNYXRoLnNpbihub2RlLmxpZ2h0bmluZ0NoYXJnZSkgKiAwLjIgKyAwLjNcbiAgICAgIH0pXG5cbiAgICAgIC8vIFJlY2FsY3VsYXRlIGNvbm5lY3Rpb25zXG4gICAgICBjYWxjdWxhdGVDb25uZWN0aW9ucygpXG5cbiAgICAgIC8vIERyYXcgY29ubmVjdGlvbnNcbiAgICAgIG5vZGVzUmVmLmN1cnJlbnQuZm9yRWFjaCgobm9kZSwgaSkgPT4ge1xuICAgICAgICBub2RlLmNvbm5lY3Rpb25zLmZvckVhY2goY29ubmVjdGlvbkluZGV4ID0+IHtcbiAgICAgICAgICBjb25zdCBvdGhlck5vZGUgPSBub2Rlc1JlZi5jdXJyZW50W2Nvbm5lY3Rpb25JbmRleF1cbiAgICAgICAgICBpZiAob3RoZXJOb2RlKSB7XG4gICAgICAgICAgICBjb25zdCBkeCA9IG5vZGUueCAtIG90aGVyTm9kZS54XG4gICAgICAgICAgICBjb25zdCBkeSA9IG5vZGUueSAtIG90aGVyTm9kZS55XG4gICAgICAgICAgICBjb25zdCBkaXN0YW5jZSA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSlcbiAgICAgICAgICAgIGNvbnN0IGFscGhhID0gKDEgLSBkaXN0YW5jZSAvIGNvbm5lY3Rpb25EaXN0YW5jZSkgKiBvcGFjaXR5ICogMC44XG5cbiAgICAgICAgICAgIC8vIFZpc2libGUgbmV1cmFsIGNvbm5lY3Rpb25zXG4gICAgICAgICAgICBjb25zdCBwdWxzZUludGVuc2l0eSA9IChNYXRoLnNpbihub2RlLnB1bHNlKSArIE1hdGguc2luKG90aGVyTm9kZS5wdWxzZSkpIC8gMlxuICAgICAgICAgICAgY29uc3QgbmV1cmFsRW5lcmd5ID0gKG5vZGUuZW5lcmd5ICsgb3RoZXJOb2RlLmVuZXJneSkgLyAyXG4gICAgICAgICAgICBjb25zdCBmbG93SW50ZW5zaXR5ID0gTWF0aC5zaW4oRGF0ZS5ub3coKSAqIDAuMDA1ICsgZGlzdGFuY2UgKiAwLjAzKSAqIDAuMyArIDAuN1xuICAgICAgICAgICAgY29uc3QgY29ubmVjdGlvbkFscGhhID0gYWxwaGEgKiAoMC42ICsgcHVsc2VJbnRlbnNpdHkgKiAwLjMgKyBuZXVyYWxFbmVyZ3kgKiAwLjIpXG5cbiAgICAgICAgICAgIC8vIFdhcm0sIHZpc2libGUgbmV1cmFsIGNvbG9yc1xuICAgICAgICAgICAgY29uc3QgbmV1cmFsQ29sb3IgPSBuZXVyYWxFbmVyZ3kgPiAwLjUgXG4gICAgICAgICAgICAgID8gYHJnYmEoMTAwLCAxODAsIDI1NSwgJHtjb25uZWN0aW9uQWxwaGEgKiBmbG93SW50ZW5zaXR5fSlgIC8vIEJyaWdodCBibHVlXG4gICAgICAgICAgICAgIDogYHJnYmEoODAsIDE1MCwgMjIwLCAke2Nvbm5lY3Rpb25BbHBoYX0pYCAgICAgICAgICAgICAgICAgLy8gTWVkaXVtIGJsdWVcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gbmV1cmFsQ29sb3JcbiAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSAxLjIgKyBuZXVyYWxFbmVyZ3kgKiAxLjggIC8vIFZpc2libGUgbGluZXNcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQ2xlYXIgZ2xvdyBmb3IgdmlzaWJpbGl0eVxuICAgICAgICAgICAgY3R4LnNoYWRvd0NvbG9yID0gbmV1cmFsQ29sb3JcbiAgICAgICAgICAgIGN0eC5zaGFkb3dCbHVyID0gMyArIG5ldXJhbEVuZXJneSAqIDZcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpXG4gICAgICAgICAgICBjdHgubW92ZVRvKG5vZGUueCwgbm9kZS55KVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBTbW9vdGgsIG9yZ2FuaWMgY29ubmVjdGlvbnNcbiAgICAgICAgICAgIGN0eC5saW5lVG8ob3RoZXJOb2RlLngsIG90aGVyTm9kZS55KVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBjdHguc3Ryb2tlKClcbiAgICAgICAgICAgIGN0eC5zaGFkb3dCbHVyID0gMFxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH0pXG5cbiAgICAgIC8vIERyYXcgZ2VudGxlLCBjb21mb3J0YWJsZSBub2Rlc1xuICAgICAgbm9kZXNSZWYuY3VycmVudC5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICBjb25zdCBwdWxzZUludGVuc2l0eSA9IE1hdGguc2luKG5vZGUucHVsc2UpICogMC4zICsgMC40XG4gICAgICAgIGNvbnN0IGdlbnRsZUVuZXJneSA9IG5vZGUuZW5lcmd5XG4gICAgICAgIGNvbnN0IG5vZGVPcGFjaXR5ID0gb3BhY2l0eSAqICgwLjUgKyBwdWxzZUludGVuc2l0eSAqIDAuMiArIGdlbnRsZUVuZXJneSAqIDAuMTUpXG4gICAgICAgIGNvbnN0IG5vZGVTaXplID0gMiArIHB1bHNlSW50ZW5zaXR5ICogMiArIGdlbnRsZUVuZXJneSAqIDEuNSAgLy8gU21hbGxlciwgZWxlZ2FudCBub2Rlc1xuICAgICAgICBjb25zdCBpc0FjdGl2ZSA9IGdlbnRsZUVuZXJneSA+IDAuNVxuXG4gICAgICAgIC8vIFNvZnQsIHR3aWxpZ2h0LWluc3BpcmVkIG5vZGUgY29sb3JzXG4gICAgICAgIGNvbnN0IG5vZGVDb2xvciA9IGlzQWN0aXZlIFxuICAgICAgICAgID8gYHJnYmEoMTQwLCAxNjUsIDIxMCwgJHtub2RlT3BhY2l0eX0pYCAvLyBTb2Z0IGxhdmVuZGVyLWJsdWVcbiAgICAgICAgICA6IGByZ2JhKDExNSwgMTQwLCAxODUsICR7bm9kZU9wYWNpdHl9KWAgLy8gTXV0ZWQgc2xhdGUtYmx1ZVxuICAgICAgICAgIFxuICAgICAgICAvLyBHZW50bGUgZ2xvdyBmb3IgYWN0aXZlIG5vZGVzXG4gICAgICAgIGlmIChpc0FjdGl2ZSkge1xuICAgICAgICAgIGN0eC5zaGFkb3dDb2xvciA9ICdyZ2JhKDE0MCwgMTY1LCAyMTAsIDAuNCknXG4gICAgICAgICAgY3R4LnNoYWRvd0JsdXIgPSA2ICsgZ2VudGxlRW5lcmd5ICogNFxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjdHguZmlsbFN0eWxlID0gbm9kZUNvbG9yXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKVxuICAgICAgICBjdHguYXJjKG5vZGUueCwgbm9kZS55LCBub2RlU2l6ZSwgMCwgTWF0aC5QSSAqIDIpXG4gICAgICAgIGN0eC5maWxsKClcbiAgICAgICAgXG4gICAgICAgIC8vIFNvZnQgaW5uZXIgY29yZSBmb3IgZGVwdGhcbiAgICAgICAgY29uc3QgY29yZUNvbG9yID0gaXNBY3RpdmUgXG4gICAgICAgICAgPyBgcmdiYSgxNjUsIDE4NSwgMjIwLCAke25vZGVPcGFjaXR5ICogMC44fSlgIFxuICAgICAgICAgIDogYHJnYmEoMTM1LCAxNTUsIDE5NSwgJHtub2RlT3BhY2l0eSAqIDAuN30pYFxuICAgICAgICAgIFxuICAgICAgICBjdHguZmlsbFN0eWxlID0gY29yZUNvbG9yXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKVxuICAgICAgICBjdHguYXJjKG5vZGUueCwgbm9kZS55LCBub2RlU2l6ZSAqIDAuNCwgMCwgTWF0aC5QSSAqIDIpXG4gICAgICAgIGN0eC5maWxsKClcbiAgICAgICAgXG4gICAgICAgIGN0eC5zaGFkb3dCbHVyID0gMFxuXG4gICAgICAgIC8vIEdlbnRsZSBhbWJpZW50IGdsb3dcbiAgICAgICAgY29uc3QgZ2xvd1JhZGl1cyA9IG5vZGVTaXplICsgcHVsc2VJbnRlbnNpdHkgKiA4ICsgZ2VudGxlRW5lcmd5ICogNlxuICAgICAgICBjb25zdCBncmFkaWVudCA9IGN0eC5jcmVhdGVSYWRpYWxHcmFkaWVudChcbiAgICAgICAgICBub2RlLngsIG5vZGUueSwgMCxcbiAgICAgICAgICBub2RlLngsIG5vZGUueSwgZ2xvd1JhZGl1c1xuICAgICAgICApXG4gICAgICAgIFxuICAgICAgICBpZiAoaXNBY3RpdmUpIHtcbiAgICAgICAgICAvLyBTb2Z0IHR3aWxpZ2h0IGdsb3cgZm9yIGFjdGl2ZSBub2Rlc1xuICAgICAgICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcCgwLCBgcmdiYSgxNjAsIDE4MCwgMjE1LCAke25vZGVPcGFjaXR5ICogMC42fSlgKVxuICAgICAgICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcCgwLjIsIGByZ2JhKDE0MCwgMTY1LCAyMDAsICR7bm9kZU9wYWNpdHkgKiAwLjR9KWApXG4gICAgICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKDAuNSwgYHJnYmEoMTIwLCAxNDUsIDE4NSwgJHtub2RlT3BhY2l0eSAqIDAuMjV9KWApXG4gICAgICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKDAuOCwgYHJnYmEoMTAwLCAxMjUsIDE3MCwgJHtub2RlT3BhY2l0eSAqIDAuMX0pYClcbiAgICAgICAgICBncmFkaWVudC5hZGRDb2xvclN0b3AoMSwgJ3JnYmEoODAsIDEwNSwgMTU1LCAwKScpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gU3VidGxlIGdsb3cgZm9yIHJlZ3VsYXIgbm9kZXNcbiAgICAgICAgICBncmFkaWVudC5hZGRDb2xvclN0b3AoMCwgYHJnYmEoMTMwLCAxNTAsIDE4NSwgJHtub2RlT3BhY2l0eSAqIDAuNX0pYClcbiAgICAgICAgICBncmFkaWVudC5hZGRDb2xvclN0b3AoMC4zLCBgcmdiYSgxMTUsIDEzNSwgMTcwLCAke25vZGVPcGFjaXR5ICogMC4zfSlgKVxuICAgICAgICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcCgwLjYsIGByZ2JhKDEwMCwgMTIwLCAxNTUsICR7bm9kZU9wYWNpdHkgKiAwLjE1fSlgKVxuICAgICAgICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcCgxLCAncmdiYSg4NSwgMTA1LCAxNDAsIDApJylcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGdyYWRpZW50XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKVxuICAgICAgICBjdHguYXJjKG5vZGUueCwgbm9kZS55LCBnbG93UmFkaXVzLCAwLCBNYXRoLlBJICogMilcbiAgICAgICAgY3R4LmZpbGwoKVxuICAgICAgfSlcblxuICAgICAgYW5pbWF0aW9uUmVmLmN1cnJlbnQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSlcbiAgICB9XG5cbiAgICAvLyBJbml0aWFsaXplXG4gICAgcmVzaXplQ2FudmFzKClcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgcmVzaXplQ2FudmFzKVxuICAgIGFuaW1hdGUoKVxuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCByZXNpemVDYW52YXMpXG4gICAgICBpZiAoYW5pbWF0aW9uUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoYW5pbWF0aW9uUmVmLmN1cnJlbnQpXG4gICAgICB9XG4gICAgfVxuICB9LCBbb3BhY2l0eSwgbm9kZUNvdW50LCBjb25uZWN0aW9uRGlzdGFuY2UsIHB1bHNlU3BlZWRdKVxuXG4gIHJldHVybiAoXG4gICAgPGNhbnZhc1xuICAgICAgcmVmPXtjYW52YXNSZWZ9XG4gICAgICBjbGFzc05hbWU9e2BmaXhlZCBpbnNldC0wIHBvaW50ZXItZXZlbnRzLW5vbmUgei0wICR7Y2xhc3NOYW1lfWB9XG4gICAgICBzdHlsZT17eyBvcGFjaXR5IH19XG4gICAgLz5cbiAgKVxufSJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJOZXVyb25pY0JhY2tncm91bmQiLCJjbGFzc05hbWUiLCJvcGFjaXR5Iiwibm9kZUNvdW50IiwiY29ubmVjdGlvbkRpc3RhbmNlIiwicHVsc2VTcGVlZCIsImNhbnZhc1JlZiIsImFuaW1hdGlvblJlZiIsIm5vZGVzUmVmIiwiY2FudmFzIiwiY3VycmVudCIsImN0eCIsImdldENvbnRleHQiLCJpbml0aWFsaXplTm9kZXMiLCJpIiwicHVzaCIsIngiLCJNYXRoIiwicmFuZG9tIiwid2lkdGgiLCJ5IiwiaGVpZ2h0IiwidngiLCJ2eSIsInB1bHNlIiwiUEkiLCJwdWxzZURpcmVjdGlvbiIsImNvbm5lY3Rpb25zIiwiZW5lcmd5IiwibGlnaHRuaW5nQ2hhcmdlIiwicmVzaXplQ2FudmFzIiwid2luZG93IiwiaW5uZXJXaWR0aCIsImlubmVySGVpZ2h0IiwiY2FsY3VsYXRlQ29ubmVjdGlvbnMiLCJmb3JFYWNoIiwibm9kZSIsIm90aGVyTm9kZSIsImoiLCJkeCIsImR5IiwiZGlzdGFuY2UiLCJzcXJ0IiwiYW5pbWF0ZSIsImNsZWFyUmVjdCIsIm1heCIsIm1pbiIsInNpbiIsImNvbm5lY3Rpb25JbmRleCIsImFscGhhIiwicHVsc2VJbnRlbnNpdHkiLCJuZXVyYWxFbmVyZ3kiLCJmbG93SW50ZW5zaXR5IiwiRGF0ZSIsIm5vdyIsImNvbm5lY3Rpb25BbHBoYSIsIm5ldXJhbENvbG9yIiwic3Ryb2tlU3R5bGUiLCJsaW5lV2lkdGgiLCJzaGFkb3dDb2xvciIsInNoYWRvd0JsdXIiLCJiZWdpblBhdGgiLCJtb3ZlVG8iLCJsaW5lVG8iLCJzdHJva2UiLCJnZW50bGVFbmVyZ3kiLCJub2RlT3BhY2l0eSIsIm5vZGVTaXplIiwiaXNBY3RpdmUiLCJub2RlQ29sb3IiLCJmaWxsU3R5bGUiLCJhcmMiLCJmaWxsIiwiY29yZUNvbG9yIiwiZ2xvd1JhZGl1cyIsImdyYWRpZW50IiwiY3JlYXRlUmFkaWFsR3JhZGllbnQiLCJhZGRDb2xvclN0b3AiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwicmVmIiwic3R5bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/ui/NeuronicBackground.tsx\n"));

/***/ })

});