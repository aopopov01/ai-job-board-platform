"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/components/ui/NeuronicBackground.tsx":
/*!**************************************************!*\
  !*** ./src/components/ui/NeuronicBackground.tsx ***!
  \**************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ NeuronicBackground; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/../../node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/../../node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\nfunction NeuronicBackground(param) {\n    let { className = \"\", opacity = 0.4, nodeCount = 35, connectionDistance = 150, pulseSpeed = 0.015 // Slower, calmer animation\n     } = param;\n    _s();\n    const canvasRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const animationRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    const nodesRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)([]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n        const ctx = canvas.getContext(\"2d\");\n        if (!ctx) return;\n        // Initialize nodes\n        const initializeNodes = ()=>{\n            nodesRef.current = [];\n            for(let i = 0; i < nodeCount; i++){\n                nodesRef.current.push({\n                    x: Math.random() * canvas.width,\n                    y: Math.random() * canvas.height,\n                    vx: (Math.random() - 0.5) * 0.5,\n                    vy: (Math.random() - 0.5) * 0.5,\n                    pulse: Math.random() * Math.PI * 2,\n                    pulseDirection: Math.random() > 0.5 ? 1 : -1,\n                    connections: [],\n                    energy: Math.random(),\n                    lightningCharge: Math.random() * Math.PI * 2\n                });\n            }\n        };\n        // Resize canvas\n        const resizeCanvas = ()=>{\n            canvas.width = window.innerWidth;\n            canvas.height = window.innerHeight;\n            initializeNodes();\n        };\n        // Calculate connections\n        const calculateConnections = ()=>{\n            nodesRef.current.forEach((node, i)=>{\n                node.connections = [];\n                nodesRef.current.forEach((otherNode, j)=>{\n                    if (i !== j) {\n                        const dx = node.x - otherNode.x;\n                        const dy = node.y - otherNode.y;\n                        const distance = Math.sqrt(dx * dx + dy * dy);\n                        if (distance < connectionDistance) {\n                            node.connections.push(j);\n                        }\n                    }\n                });\n            });\n        };\n        // Animation loop\n        const animate = ()=>{\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            // Update nodes\n            nodesRef.current.forEach((node)=>{\n                // Update position\n                node.x += node.vx;\n                node.y += node.vy;\n                // Bounce off edges\n                if (node.x <= 0 || node.x >= canvas.width) node.vx *= -1;\n                if (node.y <= 0 || node.y >= canvas.height) node.vy *= -1;\n                // Keep nodes in bounds\n                node.x = Math.max(0, Math.min(canvas.width, node.x));\n                node.y = Math.max(0, Math.min(canvas.height, node.y));\n                // Update pulse and lightning energy\n                node.pulse += pulseSpeed * node.pulseDirection;\n                if (node.pulse > Math.PI * 2) node.pulse = 0;\n                if (node.pulse < 0) node.pulse = Math.PI * 2;\n                // Update lightning charge for electric effects (reduced intensity)\n                node.lightningCharge += pulseSpeed * 1.5;\n                node.energy = Math.sin(node.lightningCharge) * 0.3 + 0.4;\n            });\n            // Recalculate connections\n            calculateConnections();\n            // Draw connections\n            nodesRef.current.forEach((node, i)=>{\n                node.connections.forEach((connectionIndex)=>{\n                    const otherNode = nodesRef.current[connectionIndex];\n                    if (otherNode) {\n                        const dx = node.x - otherNode.x;\n                        const dy = node.y - otherNode.y;\n                        const distance = Math.sqrt(dx * dx + dy * dy);\n                        const alpha = (1 - distance / connectionDistance) * opacity * 0.9 // Much more visible\n                        ;\n                        // Lightning-inspired electric connections with high visibility\n                        const pulseIntensity = (Math.sin(node.pulse) + Math.sin(otherNode.pulse)) / 2;\n                        const lightningEnergy = (node.energy + otherNode.energy) / 2;\n                        const electricIntensity = Math.sin(Date.now() * 0.008 + distance * 0.05) * 0.4 + 0.9 // More dynamic\n                        ;\n                        const connectionAlpha = alpha * (0.8 + pulseIntensity * 0.4 + lightningEnergy * 0.3 // Brighter connections\n                        );\n                        // Electric lightning colors - much more visible and vibrant\n                        const electricColor = lightningEnergy > 0.7 ? \"rgba(100, 200, 255, \".concat(connectionAlpha * electricIntensity, \")\") // Bright cyan-blue\n                         : \"rgba(60, 150, 255, \".concat(connectionAlpha, \")\") // Electric blue\n                        ;\n                        ctx.strokeStyle = electricColor;\n                        ctx.lineWidth = 2 + lightningEnergy * 2.5 // Thicker lines\n                        ;\n                        // Enhanced electric glow for better visibility\n                        ctx.shadowColor = electricColor;\n                        ctx.shadowBlur = 8 + lightningEnergy * 12 // More pronounced glow\n                        ;\n                        ctx.beginPath();\n                        ctx.moveTo(node.x, node.y);\n                        // More visible lightning-style jagged connections\n                        if (lightningEnergy > 0.8) {\n                            const midX = (node.x + otherNode.x) / 2 + (Math.random() - 0.5) * 20;\n                            const midY = (node.y + otherNode.y) / 2 + (Math.random() - 0.5) * 20;\n                            ctx.lineTo(midX, midY);\n                            ctx.lineTo(otherNode.x, otherNode.y);\n                        } else {\n                            ctx.lineTo(otherNode.x, otherNode.y);\n                        }\n                        ctx.stroke();\n                        ctx.shadowBlur = 0;\n                    }\n                });\n            });\n            // Draw lightning-charged nodes with electric energy - much more visible\n            nodesRef.current.forEach((node)=>{\n                const pulseIntensity = Math.sin(node.pulse) * 0.5 + 0.5;\n                const electricCharge = node.energy;\n                const nodeOpacity = opacity * (0.9 + pulseIntensity * 0.4 + electricCharge * 0.3 // More visible\n                );\n                const nodeSize = 6 + pulseIntensity * 6 + electricCharge * 4 // Larger nodes\n                ;\n                const isHighEnergy = electricCharge > 0.7 // Lower threshold for high energy\n                ;\n                // Lightning-charged node with vibrant electric colors\n                const nodeColor = isHighEnergy ? \"rgba(120, 220, 255, \".concat(nodeOpacity, \")\") // Bright cyan\n                 : \"rgba(80, 160, 255, \".concat(nodeOpacity, \")\") // Electric blue\n                ;\n                // Enhanced electric glow for high energy nodes\n                if (isHighEnergy) {\n                    ctx.shadowColor = \"rgba(120, 220, 255, 0.8)\" // More vibrant glow\n                    ;\n                    ctx.shadowBlur = 15 + electricCharge * 10 // Stronger glow\n                    ;\n                }\n                ctx.fillStyle = nodeColor;\n                ctx.beginPath();\n                ctx.arc(node.x, node.y, nodeSize, 0, Math.PI * 2);\n                ctx.fill();\n                // Electric core - bright but controlled for lightning nodes\n                const coreColor = isHighEnergy ? \"rgba(240, 250, 255, \".concat(nodeOpacity, \")\") : \"rgba(180, 220, 255, \".concat(nodeOpacity * 0.9, \")\");\n                ctx.fillStyle = coreColor;\n                ctx.beginPath();\n                ctx.arc(node.x, node.y, nodeSize * 0.5, 0, Math.PI * 2);\n                ctx.fill();\n                ctx.shadowBlur = 0;\n                // Electric lightning glow with controlled inspirational energy\n                const glowRadius = nodeSize + pulseIntensity * 15 + electricCharge * 8;\n                const gradient = ctx.createRadialGradient(node.x, node.y, 0, node.x, node.y, glowRadius);\n                if (isHighEnergy) {\n                    // Bright but controlled glow for high energy nodes\n                    gradient.addColorStop(0, \"rgba(220, 240, 255, \".concat(nodeOpacity * 1.2, \")\"));\n                    gradient.addColorStop(0.1, \"rgba(180, 220, 255, \".concat(nodeOpacity * 1.0, \")\"));\n                    gradient.addColorStop(0.3, \"rgba(140, 190, 255, \".concat(nodeOpacity * 0.7, \")\"));\n                    gradient.addColorStop(0.6, \"rgba(100, 150, 255, \".concat(nodeOpacity * 0.4, \")\"));\n                    gradient.addColorStop(1, \"rgba(60, 120, 200, 0)\");\n                } else {\n                    // Electric blue glow for regular nodes\n                    gradient.addColorStop(0, \"rgba(180, 220, 255, \".concat(nodeOpacity * 1.1, \")\"));\n                    gradient.addColorStop(0.2, \"rgba(140, 190, 255, \".concat(nodeOpacity * 0.8, \")\"));\n                    gradient.addColorStop(0.5, \"rgba(100, 160, 255, \".concat(nodeOpacity * 0.5, \")\"));\n                    gradient.addColorStop(0.8, \"rgba(80, 130, 220, \".concat(nodeOpacity * 0.3, \")\"));\n                    gradient.addColorStop(1, \"rgba(60, 110, 200, 0)\");\n                }\n                ctx.fillStyle = gradient;\n                ctx.beginPath();\n                ctx.arc(node.x, node.y, glowRadius, 0, Math.PI * 2);\n                ctx.fill();\n            });\n            animationRef.current = requestAnimationFrame(animate);\n        };\n        // Initialize\n        resizeCanvas();\n        window.addEventListener(\"resize\", resizeCanvas);\n        animate();\n        return ()=>{\n            window.removeEventListener(\"resize\", resizeCanvas);\n            if (animationRef.current) {\n                cancelAnimationFrame(animationRef.current);\n            }\n        };\n    }, [\n        opacity,\n        nodeCount,\n        connectionDistance,\n        pulseSpeed\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"canvas\", {\n        ref: canvasRef,\n        className: \"fixed inset-0 pointer-events-none z-0 \".concat(className),\n        style: {\n            opacity\n        }\n    }, void 0, false, {\n        fileName: \"/app/apps/web/src/components/ui/NeuronicBackground.tsx\",\n        lineNumber: 245,\n        columnNumber: 5\n    }, this);\n}\n_s(NeuronicBackground, \"eE7rkxSEFP3rCBRXkDJ01N1IvKk=\");\n_c = NeuronicBackground;\nvar _c;\n$RefreshReg$(_c, \"NeuronicBackground\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL3VpL05ldXJvbmljQmFja2dyb3VuZC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBRXlDO0FBc0IxQixTQUFTRSxtQkFBbUIsS0FNakI7UUFOaUIsRUFDekNDLFlBQVksRUFBRSxFQUNkQyxVQUFVLEdBQUcsRUFDYkMsWUFBWSxFQUFFLEVBQ2RDLHFCQUFxQixHQUFHLEVBQ3hCQyxhQUFhLE1BQU8sMkJBQTJCO0lBQTdCLEVBQ00sR0FOaUI7O0lBT3pDLE1BQU1DLFlBQVlQLDZDQUFNQSxDQUFvQjtJQUM1QyxNQUFNUSxlQUFlUiw2Q0FBTUE7SUFDM0IsTUFBTVMsV0FBV1QsNkNBQU1BLENBQVMsRUFBRTtJQUVsQ0QsZ0RBQVNBLENBQUM7UUFDUixNQUFNVyxTQUFTSCxVQUFVSSxPQUFPO1FBQ2hDLElBQUksQ0FBQ0QsUUFBUTtRQUViLE1BQU1FLE1BQU1GLE9BQU9HLFVBQVUsQ0FBQztRQUM5QixJQUFJLENBQUNELEtBQUs7UUFFVixtQkFBbUI7UUFDbkIsTUFBTUUsa0JBQWtCO1lBQ3RCTCxTQUFTRSxPQUFPLEdBQUcsRUFBRTtZQUNyQixJQUFLLElBQUlJLElBQUksR0FBR0EsSUFBSVgsV0FBV1csSUFBSztnQkFDbENOLFNBQVNFLE9BQU8sQ0FBQ0ssSUFBSSxDQUFDO29CQUNwQkMsR0FBR0MsS0FBS0MsTUFBTSxLQUFLVCxPQUFPVSxLQUFLO29CQUMvQkMsR0FBR0gsS0FBS0MsTUFBTSxLQUFLVCxPQUFPWSxNQUFNO29CQUNoQ0MsSUFBSSxDQUFDTCxLQUFLQyxNQUFNLEtBQUssR0FBRSxJQUFLO29CQUM1QkssSUFBSSxDQUFDTixLQUFLQyxNQUFNLEtBQUssR0FBRSxJQUFLO29CQUM1Qk0sT0FBT1AsS0FBS0MsTUFBTSxLQUFLRCxLQUFLUSxFQUFFLEdBQUc7b0JBQ2pDQyxnQkFBZ0JULEtBQUtDLE1BQU0sS0FBSyxNQUFNLElBQUksQ0FBQztvQkFDM0NTLGFBQWEsRUFBRTtvQkFDZkMs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O0FBR3ZCO0dBbE93QkY7S0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvdWkvTmV1cm9uaWNCYWNrZ3JvdW5kLnRzeD9lNTg0Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xuXG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gJ3JlYWN0J1xuXG5pbnRlcmZhY2UgTm9kZSB7XG4gIHg6IG51bWJlclxuICB5OiBudW1iZXJcbiAgdng6IG51bWJlclxuICB2eTogbnVtYmVyXG4gIHB1bHNlOiBudW1iZXJcbiAgcHVsc2VEaXJlY3Rpb246IG51bWJlclxuICBjb25uZWN0aW9uczogbnVtYmVyW11cbiAgZW5lcmd5OiBudW1iZXJcbiAgbGlnaHRuaW5nQ2hhcmdlOiBudW1iZXJcbn1cblxuaW50ZXJmYWNlIE5ldXJvbmljQmFja2dyb3VuZFByb3BzIHtcbiAgY2xhc3NOYW1lPzogc3RyaW5nXG4gIG9wYWNpdHk/OiBudW1iZXJcbiAgbm9kZUNvdW50PzogbnVtYmVyXG4gIGNvbm5lY3Rpb25EaXN0YW5jZT86IG51bWJlclxuICBwdWxzZVNwZWVkPzogbnVtYmVyXG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIE5ldXJvbmljQmFja2dyb3VuZCh7XG4gIGNsYXNzTmFtZSA9ICcnLFxuICBvcGFjaXR5ID0gMC40LCAgIC8vIFN1YnRsZSBhbmQgY29tZm9ydGFibGVcbiAgbm9kZUNvdW50ID0gMzUsICAvLyBGZXdlciBub2RlcyBmb3IgY2xlYW5lciBsb29rXG4gIGNvbm5lY3Rpb25EaXN0YW5jZSA9IDE1MCwgLy8gTW9kZXJhdGUgY29ubmVjdGlvbnNcbiAgcHVsc2VTcGVlZCA9IDAuMDE1ICAvLyBTbG93ZXIsIGNhbG1lciBhbmltYXRpb25cbn06IE5ldXJvbmljQmFja2dyb3VuZFByb3BzKSB7XG4gIGNvbnN0IGNhbnZhc1JlZiA9IHVzZVJlZjxIVE1MQ2FudmFzRWxlbWVudD4obnVsbClcbiAgY29uc3QgYW5pbWF0aW9uUmVmID0gdXNlUmVmPG51bWJlcj4oKVxuICBjb25zdCBub2Rlc1JlZiA9IHVzZVJlZjxOb2RlW10+KFtdKVxuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnRcbiAgICBpZiAoIWNhbnZhcykgcmV0dXJuXG5cbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKVxuICAgIGlmICghY3R4KSByZXR1cm5cblxuICAgIC8vIEluaXRpYWxpemUgbm9kZXNcbiAgICBjb25zdCBpbml0aWFsaXplTm9kZXMgPSAoKSA9PiB7XG4gICAgICBub2Rlc1JlZi5jdXJyZW50ID0gW11cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZUNvdW50OyBpKyspIHtcbiAgICAgICAgbm9kZXNSZWYuY3VycmVudC5wdXNoKHtcbiAgICAgICAgICB4OiBNYXRoLnJhbmRvbSgpICogY2FudmFzLndpZHRoLFxuICAgICAgICAgIHk6IE1hdGgucmFuZG9tKCkgKiBjYW52YXMuaGVpZ2h0LFxuICAgICAgICAgIHZ4OiAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAwLjUsXG4gICAgICAgICAgdnk6IChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIDAuNSxcbiAgICAgICAgICBwdWxzZTogTWF0aC5yYW5kb20oKSAqIE1hdGguUEkgKiAyLFxuICAgICAgICAgIHB1bHNlRGlyZWN0aW9uOiBNYXRoLnJhbmRvbSgpID4gMC41ID8gMSA6IC0xLFxuICAgICAgICAgIGNvbm5lY3Rpb25zOiBbXSxcbiAgICAgICAgICBlbmVyZ3k6IE1hdGgucmFuZG9tKCksXG4gICAgICAgICAgbGlnaHRuaW5nQ2hhcmdlOiBNYXRoLnJhbmRvbSgpICogTWF0aC5QSSAqIDJcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXNpemUgY2FudmFzXG4gICAgY29uc3QgcmVzaXplQ2FudmFzID0gKCkgPT4ge1xuICAgICAgY2FudmFzLndpZHRoID0gd2luZG93LmlubmVyV2lkdGhcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHRcbiAgICAgIGluaXRpYWxpemVOb2RlcygpXG4gICAgfVxuXG4gICAgLy8gQ2FsY3VsYXRlIGNvbm5lY3Rpb25zXG4gICAgY29uc3QgY2FsY3VsYXRlQ29ubmVjdGlvbnMgPSAoKSA9PiB7XG4gICAgICBub2Rlc1JlZi5jdXJyZW50LmZvckVhY2goKG5vZGUsIGkpID0+IHtcbiAgICAgICAgbm9kZS5jb25uZWN0aW9ucyA9IFtdXG4gICAgICAgIG5vZGVzUmVmLmN1cnJlbnQuZm9yRWFjaCgob3RoZXJOb2RlLCBqKSA9PiB7XG4gICAgICAgICAgaWYgKGkgIT09IGopIHtcbiAgICAgICAgICAgIGNvbnN0IGR4ID0gbm9kZS54IC0gb3RoZXJOb2RlLnhcbiAgICAgICAgICAgIGNvbnN0IGR5ID0gbm9kZS55IC0gb3RoZXJOb2RlLnlcbiAgICAgICAgICAgIGNvbnN0IGRpc3RhbmNlID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KVxuICAgICAgICAgICAgaWYgKGRpc3RhbmNlIDwgY29ubmVjdGlvbkRpc3RhbmNlKSB7XG4gICAgICAgICAgICAgIG5vZGUuY29ubmVjdGlvbnMucHVzaChqKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gQW5pbWF0aW9uIGxvb3BcbiAgICBjb25zdCBhbmltYXRlID0gKCkgPT4ge1xuICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpXG4gICAgICBcbiAgICAgIC8vIFVwZGF0ZSBub2Rlc1xuICAgICAgbm9kZXNSZWYuY3VycmVudC5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICAvLyBVcGRhdGUgcG9zaXRpb25cbiAgICAgICAgbm9kZS54ICs9IG5vZGUudnhcbiAgICAgICAgbm9kZS55ICs9IG5vZGUudnlcblxuICAgICAgICAvLyBCb3VuY2Ugb2ZmIGVkZ2VzXG4gICAgICAgIGlmIChub2RlLnggPD0gMCB8fCBub2RlLnggPj0gY2FudmFzLndpZHRoKSBub2RlLnZ4ICo9IC0xXG4gICAgICAgIGlmIChub2RlLnkgPD0gMCB8fCBub2RlLnkgPj0gY2FudmFzLmhlaWdodCkgbm9kZS52eSAqPSAtMVxuXG4gICAgICAgIC8vIEtlZXAgbm9kZXMgaW4gYm91bmRzXG4gICAgICAgIG5vZGUueCA9IE1hdGgubWF4KDAsIE1hdGgubWluKGNhbnZhcy53aWR0aCwgbm9kZS54KSlcbiAgICAgICAgbm9kZS55ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oY2FudmFzLmhlaWdodCwgbm9kZS55KSlcblxuICAgICAgICAvLyBVcGRhdGUgcHVsc2UgYW5kIGxpZ2h0bmluZyBlbmVyZ3lcbiAgICAgICAgbm9kZS5wdWxzZSArPSBwdWxzZVNwZWVkICogbm9kZS5wdWxzZURpcmVjdGlvblxuICAgICAgICBpZiAobm9kZS5wdWxzZSA+IE1hdGguUEkgKiAyKSBub2RlLnB1bHNlID0gMFxuICAgICAgICBpZiAobm9kZS5wdWxzZSA8IDApIG5vZGUucHVsc2UgPSBNYXRoLlBJICogMlxuICAgICAgICBcbiAgICAgICAgLy8gVXBkYXRlIGxpZ2h0bmluZyBjaGFyZ2UgZm9yIGVsZWN0cmljIGVmZmVjdHMgKHJlZHVjZWQgaW50ZW5zaXR5KVxuICAgICAgICBub2RlLmxpZ2h0bmluZ0NoYXJnZSArPSBwdWxzZVNwZWVkICogMS41XG4gICAgICAgIG5vZGUuZW5lcmd5ID0gTWF0aC5zaW4obm9kZS5saWdodG5pbmdDaGFyZ2UpICogMC4zICsgMC40XG4gICAgICB9KVxuXG4gICAgICAvLyBSZWNhbGN1bGF0ZSBjb25uZWN0aW9uc1xuICAgICAgY2FsY3VsYXRlQ29ubmVjdGlvbnMoKVxuXG4gICAgICAvLyBEcmF3IGNvbm5lY3Rpb25zXG4gICAgICBub2Rlc1JlZi5jdXJyZW50LmZvckVhY2goKG5vZGUsIGkpID0+IHtcbiAgICAgICAgbm9kZS5jb25uZWN0aW9ucy5mb3JFYWNoKGNvbm5lY3Rpb25JbmRleCA9PiB7XG4gICAgICAgICAgY29uc3Qgb3RoZXJOb2RlID0gbm9kZXNSZWYuY3VycmVudFtjb25uZWN0aW9uSW5kZXhdXG4gICAgICAgICAgaWYgKG90aGVyTm9kZSkge1xuICAgICAgICAgICAgY29uc3QgZHggPSBub2RlLnggLSBvdGhlck5vZGUueFxuICAgICAgICAgICAgY29uc3QgZHkgPSBub2RlLnkgLSBvdGhlck5vZGUueVxuICAgICAgICAgICAgY29uc3QgZGlzdGFuY2UgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpXG4gICAgICAgICAgICBjb25zdCBhbHBoYSA9ICgxIC0gZGlzdGFuY2UgLyBjb25uZWN0aW9uRGlzdGFuY2UpICogb3BhY2l0eSAqIDAuOSAgLy8gTXVjaCBtb3JlIHZpc2libGVcblxuICAgICAgICAgICAgLy8gTGlnaHRuaW5nLWluc3BpcmVkIGVsZWN0cmljIGNvbm5lY3Rpb25zIHdpdGggaGlnaCB2aXNpYmlsaXR5XG4gICAgICAgICAgICBjb25zdCBwdWxzZUludGVuc2l0eSA9IChNYXRoLnNpbihub2RlLnB1bHNlKSArIE1hdGguc2luKG90aGVyTm9kZS5wdWxzZSkpIC8gMlxuICAgICAgICAgICAgY29uc3QgbGlnaHRuaW5nRW5lcmd5ID0gKG5vZGUuZW5lcmd5ICsgb3RoZXJOb2RlLmVuZXJneSkgLyAyXG4gICAgICAgICAgICBjb25zdCBlbGVjdHJpY0ludGVuc2l0eSA9IE1hdGguc2luKERhdGUubm93KCkgKiAwLjAwOCArIGRpc3RhbmNlICogMC4wNSkgKiAwLjQgKyAwLjkgIC8vIE1vcmUgZHluYW1pY1xuICAgICAgICAgICAgY29uc3QgY29ubmVjdGlvbkFscGhhID0gYWxwaGEgKiAoMC44ICsgcHVsc2VJbnRlbnNpdHkgKiAwLjQgKyBsaWdodG5pbmdFbmVyZ3kgKiAwLjMpICAvLyBCcmlnaHRlciBjb25uZWN0aW9uc1xuXG4gICAgICAgICAgICAvLyBFbGVjdHJpYyBsaWdodG5pbmcgY29sb3JzIC0gbXVjaCBtb3JlIHZpc2libGUgYW5kIHZpYnJhbnRcbiAgICAgICAgICAgIGNvbnN0IGVsZWN0cmljQ29sb3IgPSBsaWdodG5pbmdFbmVyZ3kgPiAwLjcgXG4gICAgICAgICAgICAgID8gYHJnYmEoMTAwLCAyMDAsIDI1NSwgJHtjb25uZWN0aW9uQWxwaGEgKiBlbGVjdHJpY0ludGVuc2l0eX0pYCAvLyBCcmlnaHQgY3lhbi1ibHVlXG4gICAgICAgICAgICAgIDogYHJnYmEoNjAsIDE1MCwgMjU1LCAke2Nvbm5lY3Rpb25BbHBoYX0pYCAgICAgICAgICAgICAgICAgICAgIC8vIEVsZWN0cmljIGJsdWVcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gZWxlY3RyaWNDb2xvclxuICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDIgKyBsaWdodG5pbmdFbmVyZ3kgKiAyLjUgIC8vIFRoaWNrZXIgbGluZXNcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gRW5oYW5jZWQgZWxlY3RyaWMgZ2xvdyBmb3IgYmV0dGVyIHZpc2liaWxpdHlcbiAgICAgICAgICAgIGN0eC5zaGFkb3dDb2xvciA9IGVsZWN0cmljQ29sb3JcbiAgICAgICAgICAgIGN0eC5zaGFkb3dCbHVyID0gOCArIGxpZ2h0bmluZ0VuZXJneSAqIDEyICAvLyBNb3JlIHByb25vdW5jZWQgZ2xvd1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKClcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8obm9kZS54LCBub2RlLnkpXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIE1vcmUgdmlzaWJsZSBsaWdodG5pbmctc3R5bGUgamFnZ2VkIGNvbm5lY3Rpb25zXG4gICAgICAgICAgICBpZiAobGlnaHRuaW5nRW5lcmd5ID4gMC44KSB7XG4gICAgICAgICAgICAgIGNvbnN0IG1pZFggPSAobm9kZS54ICsgb3RoZXJOb2RlLngpIC8gMiArIChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIDIwXG4gICAgICAgICAgICAgIGNvbnN0IG1pZFkgPSAobm9kZS55ICsgb3RoZXJOb2RlLnkpIC8gMiArIChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIDIwXG4gICAgICAgICAgICAgIGN0eC5saW5lVG8obWlkWCwgbWlkWSlcbiAgICAgICAgICAgICAgY3R4LmxpbmVUbyhvdGhlck5vZGUueCwgb3RoZXJOb2RlLnkpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjdHgubGluZVRvKG90aGVyTm9kZS54LCBvdGhlck5vZGUueSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY3R4LnN0cm9rZSgpXG4gICAgICAgICAgICBjdHguc2hhZG93Qmx1ciA9IDBcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9KVxuXG4gICAgICAvLyBEcmF3IGxpZ2h0bmluZy1jaGFyZ2VkIG5vZGVzIHdpdGggZWxlY3RyaWMgZW5lcmd5IC0gbXVjaCBtb3JlIHZpc2libGVcbiAgICAgIG5vZGVzUmVmLmN1cnJlbnQuZm9yRWFjaChub2RlID0+IHtcbiAgICAgICAgY29uc3QgcHVsc2VJbnRlbnNpdHkgPSBNYXRoLnNpbihub2RlLnB1bHNlKSAqIDAuNSArIDAuNVxuICAgICAgICBjb25zdCBlbGVjdHJpY0NoYXJnZSA9IG5vZGUuZW5lcmd5XG4gICAgICAgIGNvbnN0IG5vZGVPcGFjaXR5ID0gb3BhY2l0eSAqICgwLjkgKyBwdWxzZUludGVuc2l0eSAqIDAuNCArIGVsZWN0cmljQ2hhcmdlICogMC4zKSAgLy8gTW9yZSB2aXNpYmxlXG4gICAgICAgIGNvbnN0IG5vZGVTaXplID0gNiArIHB1bHNlSW50ZW5zaXR5ICogNiArIGVsZWN0cmljQ2hhcmdlICogNCAgLy8gTGFyZ2VyIG5vZGVzXG4gICAgICAgIGNvbnN0IGlzSGlnaEVuZXJneSA9IGVsZWN0cmljQ2hhcmdlID4gMC43ICAvLyBMb3dlciB0aHJlc2hvbGQgZm9yIGhpZ2ggZW5lcmd5XG5cbiAgICAgICAgLy8gTGlnaHRuaW5nLWNoYXJnZWQgbm9kZSB3aXRoIHZpYnJhbnQgZWxlY3RyaWMgY29sb3JzXG4gICAgICAgIGNvbnN0IG5vZGVDb2xvciA9IGlzSGlnaEVuZXJneSBcbiAgICAgICAgICA/IGByZ2JhKDEyMCwgMjIwLCAyNTUsICR7bm9kZU9wYWNpdHl9KWAgLy8gQnJpZ2h0IGN5YW5cbiAgICAgICAgICA6IGByZ2JhKDgwLCAxNjAsIDI1NSwgJHtub2RlT3BhY2l0eX0pYCAgLy8gRWxlY3RyaWMgYmx1ZVxuICAgICAgICAgIFxuICAgICAgICAvLyBFbmhhbmNlZCBlbGVjdHJpYyBnbG93IGZvciBoaWdoIGVuZXJneSBub2Rlc1xuICAgICAgICBpZiAoaXNIaWdoRW5lcmd5KSB7XG4gICAgICAgICAgY3R4LnNoYWRvd0NvbG9yID0gJ3JnYmEoMTIwLCAyMjAsIDI1NSwgMC44KScgIC8vIE1vcmUgdmlicmFudCBnbG93XG4gICAgICAgICAgY3R4LnNoYWRvd0JsdXIgPSAxNSArIGVsZWN0cmljQ2hhcmdlICogMTAgICAgICAvLyBTdHJvbmdlciBnbG93XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBub2RlQ29sb3JcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpXG4gICAgICAgIGN0eC5hcmMobm9kZS54LCBub2RlLnksIG5vZGVTaXplLCAwLCBNYXRoLlBJICogMilcbiAgICAgICAgY3R4LmZpbGwoKVxuICAgICAgICBcbiAgICAgICAgLy8gRWxlY3RyaWMgY29yZSAtIGJyaWdodCBidXQgY29udHJvbGxlZCBmb3IgbGlnaHRuaW5nIG5vZGVzXG4gICAgICAgIGNvbnN0IGNvcmVDb2xvciA9IGlzSGlnaEVuZXJneSBcbiAgICAgICAgICA/IGByZ2JhKDI0MCwgMjUwLCAyNTUsICR7bm9kZU9wYWNpdHl9KWAgXG4gICAgICAgICAgOiBgcmdiYSgxODAsIDIyMCwgMjU1LCAke25vZGVPcGFjaXR5ICogMC45fSlgXG4gICAgICAgICAgXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBjb3JlQ29sb3JcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpXG4gICAgICAgIGN0eC5hcmMobm9kZS54LCBub2RlLnksIG5vZGVTaXplICogMC41LCAwLCBNYXRoLlBJICogMilcbiAgICAgICAgY3R4LmZpbGwoKVxuICAgICAgICBcbiAgICAgICAgY3R4LnNoYWRvd0JsdXIgPSAwXG5cbiAgICAgICAgLy8gRWxlY3RyaWMgbGlnaHRuaW5nIGdsb3cgd2l0aCBjb250cm9sbGVkIGluc3BpcmF0aW9uYWwgZW5lcmd5XG4gICAgICAgIGNvbnN0IGdsb3dSYWRpdXMgPSBub2RlU2l6ZSArIHB1bHNlSW50ZW5zaXR5ICogMTUgKyBlbGVjdHJpY0NoYXJnZSAqIDhcbiAgICAgICAgY29uc3QgZ3JhZGllbnQgPSBjdHguY3JlYXRlUmFkaWFsR3JhZGllbnQoXG4gICAgICAgICAgbm9kZS54LCBub2RlLnksIDAsXG4gICAgICAgICAgbm9kZS54LCBub2RlLnksIGdsb3dSYWRpdXNcbiAgICAgICAgKVxuICAgICAgICBcbiAgICAgICAgaWYgKGlzSGlnaEVuZXJneSkge1xuICAgICAgICAgIC8vIEJyaWdodCBidXQgY29udHJvbGxlZCBnbG93IGZvciBoaWdoIGVuZXJneSBub2Rlc1xuICAgICAgICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcCgwLCBgcmdiYSgyMjAsIDI0MCwgMjU1LCAke25vZGVPcGFjaXR5ICogMS4yfSlgKVxuICAgICAgICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcCgwLjEsIGByZ2JhKDE4MCwgMjIwLCAyNTUsICR7bm9kZU9wYWNpdHkgKiAxLjB9KWApXG4gICAgICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKDAuMywgYHJnYmEoMTQwLCAxOTAsIDI1NSwgJHtub2RlT3BhY2l0eSAqIDAuN30pYClcbiAgICAgICAgICBncmFkaWVudC5hZGRDb2xvclN0b3AoMC42LCBgcmdiYSgxMDAsIDE1MCwgMjU1LCAke25vZGVPcGFjaXR5ICogMC40fSlgKVxuICAgICAgICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcCgxLCAncmdiYSg2MCwgMTIwLCAyMDAsIDApJylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBFbGVjdHJpYyBibHVlIGdsb3cgZm9yIHJlZ3VsYXIgbm9kZXNcbiAgICAgICAgICBncmFkaWVudC5hZGRDb2xvclN0b3AoMCwgYHJnYmEoMTgwLCAyMjAsIDI1NSwgJHtub2RlT3BhY2l0eSAqIDEuMX0pYClcbiAgICAgICAgICBncmFkaWVudC5hZGRDb2xvclN0b3AoMC4yLCBgcmdiYSgxNDAsIDE5MCwgMjU1LCAke25vZGVPcGFjaXR5ICogMC44fSlgKVxuICAgICAgICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcCgwLjUsIGByZ2JhKDEwMCwgMTYwLCAyNTUsICR7bm9kZU9wYWNpdHkgKiAwLjV9KWApXG4gICAgICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKDAuOCwgYHJnYmEoODAsIDEzMCwgMjIwLCAke25vZGVPcGFjaXR5ICogMC4zfSlgKVxuICAgICAgICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcCgxLCAncmdiYSg2MCwgMTEwLCAyMDAsIDApJylcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGdyYWRpZW50XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKVxuICAgICAgICBjdHguYXJjKG5vZGUueCwgbm9kZS55LCBnbG93UmFkaXVzLCAwLCBNYXRoLlBJICogMilcbiAgICAgICAgY3R4LmZpbGwoKVxuICAgICAgfSlcblxuICAgICAgYW5pbWF0aW9uUmVmLmN1cnJlbnQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSlcbiAgICB9XG5cbiAgICAvLyBJbml0aWFsaXplXG4gICAgcmVzaXplQ2FudmFzKClcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgcmVzaXplQ2FudmFzKVxuICAgIGFuaW1hdGUoKVxuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCByZXNpemVDYW52YXMpXG4gICAgICBpZiAoYW5pbWF0aW9uUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoYW5pbWF0aW9uUmVmLmN1cnJlbnQpXG4gICAgICB9XG4gICAgfVxuICB9LCBbb3BhY2l0eSwgbm9kZUNvdW50LCBjb25uZWN0aW9uRGlzdGFuY2UsIHB1bHNlU3BlZWRdKVxuXG4gIHJldHVybiAoXG4gICAgPGNhbnZhc1xuICAgICAgcmVmPXtjYW52YXNSZWZ9XG4gICAgICBjbGFzc05hbWU9e2BmaXhlZCBpbnNldC0wIHBvaW50ZXItZXZlbnRzLW5vbmUgei0wICR7Y2xhc3NOYW1lfWB9XG4gICAgICBzdHlsZT17eyBvcGFjaXR5IH19XG4gICAgLz5cbiAgKVxufSJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJOZXVyb25pY0JhY2tncm91bmQiLCJjbGFzc05hbWUiLCJvcGFjaXR5Iiwibm9kZUNvdW50IiwiY29ubmVjdGlvbkRpc3RhbmNlIiwicHVsc2VTcGVlZCIsImNhbnZhc1JlZiIsImFuaW1hdGlvblJlZiIsIm5vZGVzUmVmIiwiY2FudmFzIiwiY3VycmVudCIsImN0eCIsImdldENvbnRleHQiLCJpbml0aWFsaXplTm9kZXMiLCJpIiwicHVzaCIsIngiLCJNYXRoIiwicmFuZG9tIiwid2lkdGgiLCJ5IiwiaGVpZ2h0IiwidngiLCJ2eSIsInB1bHNlIiwiUEkiLCJwdWxzZURpcmVjdGlvbiIsImNvbm5lY3Rpb25zIiwiZW5lcmd5IiwibGlnaHRuaW5nQ2hhcmdlIiwicmVzaXplQ2FudmFzIiwid2luZG93IiwiaW5uZXJXaWR0aCIsImlubmVySGVpZ2h0IiwiY2FsY3VsYXRlQ29ubmVjdGlvbnMiLCJmb3JFYWNoIiwibm9kZSIsIm90aGVyTm9kZSIsImoiLCJkeCIsImR5IiwiZGlzdGFuY2UiLCJzcXJ0IiwiYW5pbWF0ZSIsImNsZWFyUmVjdCIsIm1heCIsIm1pbiIsInNpbiIsImNvbm5lY3Rpb25JbmRleCIsImFscGhhIiwicHVsc2VJbnRlbnNpdHkiLCJsaWdodG5pbmdFbmVyZ3kiLCJlbGVjdHJpY0ludGVuc2l0eSIsIkRhdGUiLCJub3ciLCJjb25uZWN0aW9uQWxwaGEiLCJlbGVjdHJpY0NvbG9yIiwic3Ryb2tlU3R5bGUiLCJsaW5lV2lkdGgiLCJzaGFkb3dDb2xvciIsInNoYWRvd0JsdXIiLCJiZWdpblBhdGgiLCJtb3ZlVG8iLCJtaWRYIiwibWlkWSIsImxpbmVUbyIsInN0cm9rZSIsImVsZWN0cmljQ2hhcmdlIiwibm9kZU9wYWNpdHkiLCJub2RlU2l6ZSIsImlzSGlnaEVuZXJneSIsIm5vZGVDb2xvciIsImZpbGxTdHlsZSIsImFyYyIsImZpbGwiLCJjb3JlQ29sb3IiLCJnbG93UmFkaXVzIiwiZ3JhZGllbnQiLCJjcmVhdGVSYWRpYWxHcmFkaWVudCIsImFkZENvbG9yU3RvcCIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJyZWYiLCJzdHlsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/ui/NeuronicBackground.tsx\n"));

/***/ })

});